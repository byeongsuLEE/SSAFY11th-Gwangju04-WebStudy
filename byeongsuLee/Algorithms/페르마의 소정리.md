# [java][알고리즘]5607 조합

# 문제

[SW Expert Academy](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXGKdbqczEDFAUo)

---

# 접근 방법

- 수업 페르마의 소정리 사용
- 분할 정복을 이용한 연산 복잡도 줄이기

---

# 배운 내용

- 큰 수를 작은수의 mod p 를 구하기 위해서 페르마를 사용하지만
- 이번은 분수의 mod p 를 구하기 위해서 페르마의 소정리를 사용
- 분할정복 사용법

---

# 어려웠던 점

- 분수에서 p-2승으로 되는데 어떻게 큰수가 작은수로 되는 데  페르마 소정리를 사용하는 이유에 대해 이해가 되지 않았다 .
- 분할정복에 대한 문제를 풀어보지 않아서 구현과 이해가 쉽게 되지 않았다.

---

# 구현 코드

```jsx
	package day0401;
	
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.util.StringTokenizer;
	
	public class Solution_5607_이병수 {
	
		private static int N;
		private static int R;
		private static int p = 1234567891;
	
		public static void main(String[] args) throws IOException {
			// TODO Auto-generated method stub
	
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			StringBuilder sb = new StringBuilder();
			StringTokenizer st = null;
			int T = Integer.parseInt(br.readLine());
			for (int t = 1; t <= T; t++) {
				Long answer = 0L;
				st = new StringTokenizer(br.readLine());
				N = Integer.parseInt(st.nextToken());
				R = Integer.parseInt(st.nextToken());
	
	
				// 페르마의 소정리
				// p가 소수이고 a가 정수일떄 a^p  <=>  a(mod P)는 합동이다. 나머지가 같은수다.
				// a^ p-2 mod(p)와 a^-1 (mod p) 는 같다는 뜻이다.
				// a= r! n-r !
				// 의문점 : 이걸쓰는 이유가 큰수의 나머지를 작은수의 나머지랑 같아서 쓰는 거아닌가?
				// nCr은 a^-1에서 a^p-2가 되는건데 작은수에서 큰수로바꿔서 그나머지를 계산하는 이유가 무엇인지 모르겠음
				// 의문점해결 = a^-1는 분수이므로 mod p를 하기어렵다. 따라서 분자형태의 곱셈형태로 바꿔준다.
				answer =nCr(N, R);
				
	
				sb.append("#").append(t).append(" ").append(answer).append("\n");
			}
			System.out.println(sb.toString());
	
		}
	
		private static long power(long x , long y) {
			//x는 밑 y는 지수
			//power 분할정복하는 이유 
			//- 2^1232131231231 처럼 2를 진짜 많이곱하면 시간이 오래걸린다.
			//- 시간을 log2(지수) 만큼 줄이기 위해서 분할정복을 사용한다.
			//x % p 하는 이유 : x= (n-r) ! or r! 엄청큰 수가 오기 때문에 나누어줍시다.
			// y/2 ==1 일시에   나눌게 없다. 
	
			if(y==1) return x ;
			
			long res =power(x,y/2);
			res= (res*res)%p; 
			
			return y%2==0 ? res : (x*res) %p;   //짝수일때는 2^5 2^5  홀수일때는 2X 2^5 2^5
			
			//이건 for문으로 거듭제곱 분할정복하는 방법
	//		long res = 1L;
	//		x = x % p;
	//		while(y>0) {
	//			if(y%2==1) {
	//				res = (res * x)%p;
	//			}
	//			y = y>>1; // y= y/2
	//			x = (x*x) % p;
	//		}
	//		return res ;
	
	
		}
	
		private static long nCr(int n, int r) {
			// nCr = n! / (n-r)! r!
			// a= (n-r)! r! 두면 
			// nCr (mod p) = n!a^-1 (mod P) 이 나옴
			// 페르마 공식 5^7 = 5 mod(7)  => a^p = a mod(p)  => a^(p-2) = a^-1 (mod p) 
			// 여기서 페르마공식에서 =는 합동식을 말한다 원래 짝대기 3개로 표시해야함
			// 즉,nCr (mod p) 
			//= n!a^-1 (mod p) 
			//= n!a^(p-2) (mod p)가된다.
			//= n! *r!^(p-2) *  n(n-r)!^(p-2)  (mod p) 
			
			
			if (r == 0) {
				return 1L;
			}
			long[] fac = new long[n + 1];
			fac[0] = 1;
	
			for (int i = 1; i <= n; i++) {
				fac[i] = fac[i - 1] * i % p;
			}
	
			return (fac[n] * power(fac[r], p - 2) % p * power(fac[n - r], p - 2) 
					% p) % p;
	
		}
	
	}

```

---
